namespace Minerals.AutoCQRS.Generators
{
    [Generator]
    public sealed class ServiceCollectionExtensionsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var handlers = context.SyntaxProvider.CreateSyntaxProvider
            (
                static (x, _) => CheckForGenericInterfaces(x),
                static (x, _) => x
            );
            handlers = handlers.Where(CheckForValidInterfaces);
            var collected = handlers.Select((x, _) => SelectFullTypeNameFromSyntax(x)).Collect();

            context.RegisterSourceOutput(collected, static (ctx, collectedTypeNames) =>
            {
                ctx.AddSource("ServiceCollectionExtensions.g.cs", GenerateStaticClass(collectedTypeNames));
            });
        }

        private static bool CheckForGenericInterfaces(SyntaxNode node)
        {
            return node is TypeDeclarationSyntax syntax
                && syntax.BaseList is not null
                && syntax.BaseList.Types.Count > 0
                && syntax.BaseList.Types.Any(x => x.Type.ChildNodes().Any(y => y is GenericNameSyntax));
        }

        private static bool CheckForValidInterfaces(GeneratorSyntaxContext context)
        {
            var current = context.SemanticModel.GetDeclaredSymbol(context.Node) as ITypeSymbol;
            if (current is not null)
            {
                return current.Interfaces.Any(x =>
                {
                    return (x.Name.Equals("ICommandHandler") || x.Name.Equals("IQueryHandler"))
                        && x.ContainingNamespace.Name.Equals("Interfaces")
                        && x.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(AutoCQRS))
                        && x.ContainingNamespace.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(Minerals));
                });
            }
            return false;
        }

        private static string SelectFullTypeNameFromSyntax(GeneratorSyntaxContext context)
        {
            return context.SemanticModel.GetDeclaredSymbol(context.Node)!
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        }

        private static SourceText GenerateStaticClass(ImmutableArray<string> names)
        {
            var builder = new CodeBuilder();
            builder.AddAutoGeneratedHeader(Assembly.GetExecutingAssembly());
            AppendNamespace(builder);

            builder.AddAutoGeneratedAttributes(typeof(ClassDeclarationSyntax));
            AppendStaticClassHeader(builder);
            AppendAddCommandsAndQueriesMethod(builder, names);
            AppendDefaultInjectPolicyMethod(builder);

            builder.CloseAllBlocks();
            return SourceText.From(builder.ToString(), Encoding.UTF8);
        }

        private static void AppendNamespace(CodeBuilder builder)
        {
            builder.WriteLine("namespace Minerals.AutoCQRS")
                .OpenBlock()
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection.Extensions;")
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection;");
        }

        private static void AppendStaticClassHeader(CodeBuilder builder)
        {
            builder.WriteLine("public static class ServiceCollectionExtensions")
                .OpenBlock();
        }

        private static void AppendAddCommandsAndQueriesMethod(CodeBuilder builder, ImmutableArray<string> names)
        {
            builder.WriteLine("public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection AddCommandsAndQueries")
                .Write("(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, ")
                .Write("global::System.Action<global::Microsoft.Extensions.DependencyInjection.IServiceCollection, global::System.Type> injectPolicy = null)")
                .OpenBlock();

            builder.WriteLine("if (injectPolicy is null)")
                .OpenBlock()
                .WriteLine("injectPolicy = DefaultInjectPolicy;")
                .CloseBlock();

            builder.WriteLine("collection.TryAddSingleton<global::Minerals.AutoCQRS.Interfaces.ICommandDispatcher, global::Minerals.AutoCQRS.CommandDispatcher>();");
            builder.WriteLine("collection.TryAddSingleton<global::Minerals.AutoCQRS.Interfaces.IQueryDispatcher, global::Minerals.AutoCQRS.QueryDispatcher>();");

            foreach (var name in names)
            {
                builder.WriteLine("injectPolicy.Invoke(collection, typeof(")
                    .Write(name)
                    .Write("));");
            }

            builder.WriteLine("return collection;")
                .CloseBlock()
                .NewLine();
        }

        private static void AppendDefaultInjectPolicyMethod(CodeBuilder builder)
        {
            builder.WriteLine("private static void DefaultInjectPolicy(global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, global::System.Type serviceType)")
                .OpenBlock()
                .WriteLine("collection.AddSingleton(serviceType);")
                .CloseBlock();
        }
    }
}