namespace Minerals.AutoCQRS.Generators
{
    [Generator]
    public sealed class IServiceCollectionExtensionsGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var handlers = context.SyntaxProvider.CreateSyntaxProvider
            (
                static (x, _) => CheckForInterfaces(x),
                static (x, _) => GetValidOrNullHandlerNameObject(x)
            ).Where(x => x is not null);

            var pipelines = context.SyntaxProvider.CreateSyntaxProvider
            (
                static (x, _) => CheckForInterfaces(x),
                static (x, _) => GetValidOrNullPipelineNameObject(x)
            ).Where(x => x is not null);

            var notNullPipelines = pipelines.Select((x, _) => (PipelineNameObject)x!);
            var notNullHandlers = handlers.Select((x, _) => (HandlerNameObject)x!);

            var collectedPipelines = notNullPipelines.Collect();
            var collectedHandlers = notNullHandlers.Collect();

            var combinedAll = collectedHandlers.Combine(collectedPipelines);

            context.RegisterSourceOutput(combinedAll, static (ctx, collected) =>
            {
                ctx.AddSource
                (
                    $"{Constants.IServiceCollectionExtensions}.g.cs",
                    GenerateStaticClass(collected.Left, collected.Right)
                );
            });
        }

        private static bool CheckForInterfaces(SyntaxNode node)
        {
            return node is (not InterfaceDeclarationSyntax) and TypeDeclarationSyntax typeSyntax
                && typeSyntax.BaseList is not null
                && typeSyntax.BaseList.Types.Count > 0;
        }

        private static PipelineNameObject? GetValidOrNullPipelineNameObject(GeneratorSyntaxContext context)
        {
            var symbol = (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node)!;
            return HasValidInterfaceForPipeline(symbol) ? new PipelineNameObject(symbol) : null;
        }

        private static HandlerNameObject? GetValidOrNullHandlerNameObject(GeneratorSyntaxContext context)
        {
            var symbol = (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node)!;
            return HasValidInterfaceForHandler(symbol) ? new HandlerNameObject(symbol) : null;
        }

        private static bool HasValidInterfaceForPipeline(ITypeSymbol symbol)
        {
            return symbol.Interfaces.Any(x =>
            {
                return (x.Name.Equals(Constants.ICommandPipeline) || x.Name.Equals(Constants.IQueryPipeline))
                    && x.ContainingNamespace.Name.Equals(nameof(AutoCQRS))
                    && x.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(Minerals));
            });
        }

        private static bool HasValidInterfaceForHandler(ITypeSymbol symbol)
        {
            return symbol.Interfaces.Any(x =>
            {
                return (x.Name.Equals(Constants.ICommandHandler) || x.Name.Equals(Constants.IQueryHandler))
                    && x.ContainingNamespace.Name.Equals(nameof(AutoCQRS))
                    && x.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(Minerals));
            });
        }

        private static SourceText GenerateStaticClass(ImmutableArray<HandlerNameObject> handlers, ImmutableArray<PipelineNameObject> pipelines)
        {
            var builder = new CodeBuilder();
            builder.AddAutoGeneratedHeader(Assembly.GetExecutingAssembly());
            AppendNamespace(builder);

            builder.AddAutoGeneratedAttributes(typeof(ClassDeclarationSyntax));
            AppendStaticClassHeader(builder);

            AppendExtensionMethodHeader(builder, Constants.HandlerDispatchers, Constants.AddAutoCQRSHandlers);
            AppendExtensionMethodBody(builder, handlers);

            AppendExtensionMethodHeader(builder, Constants.PipelineDispatchers, Constants.AddAutoCQRSPipelines);
            AppendExtensionMethodBody(builder, pipelines);

            AppendDefaultInjectPolicyMethod(builder);

            builder.CloseAllBlocks();
            return SourceText.From(builder.ToString(), Encoding.UTF8);
        }

        private static void AppendNamespace(CodeBuilder builder)
        {
            builder.WriteLine("namespace Minerals.AutoCQRS")
                .OpenBlock()
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection.Extensions;")
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection;");
        }

        private static void AppendStaticClassHeader(CodeBuilder builder)
        {
            builder.WriteLine("public static class ")
                .Write(Constants.IServiceCollectionExtensions)
                .OpenBlock();
        }

        private static void AppendExtensionMethodHeader(CodeBuilder builder, IEnumerable<string> dispatchers, string methodName)
        {
            builder.WriteLine("public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection ")
                .Write(methodName)
                .Write("(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, ")
                .Write("global::System.Action<global::Microsoft.Extensions.DependencyInjection.IServiceCollection, global::System.Type, global::System.Type> injectPolicy = null)")
                .OpenBlock();

            builder.WriteLine("if (injectPolicy is null)")
                .OpenBlock()
                .WriteLine("injectPolicy = DefaultInjectPolicy;")
                .CloseBlock();

            foreach (var item in dispatchers)
            {
                builder.WriteLine("collection.TryAddSingleton<")
                    .Write(item)
                    .Write(">();");
            }
        }

        private static void AppendExtensionMethodBody(CodeBuilder builder, IEnumerable<NameObject> handlers)
        {
            foreach (var item in handlers)
            {
                builder.WriteLine("injectPolicy.Invoke(collection, typeof(")
                    .Write(item.InterfaceFullTypeName)
                    .Write("), typeof(")
                    .Write(item.FullTypeName)
                    .Write("));");
            }
            builder.WriteLine("return collection;")
                .CloseBlock()
                .NewLine();
        }

        private static void AppendDefaultInjectPolicyMethod(CodeBuilder builder)
        {
            builder.WriteLine("private static void DefaultInjectPolicy(global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, global::System.Type interfaceType, global::System.Type serviceType)")
                .OpenBlock()
                .WriteLine("collection.AddSingleton(interfaceType, serviceType);")
                .CloseBlock();
        }
    }
}