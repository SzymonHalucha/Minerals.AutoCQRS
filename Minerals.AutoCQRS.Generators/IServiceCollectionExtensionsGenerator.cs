namespace Minerals.AutoCQRS.Generators
{
    [Generator]
    public sealed class IServiceCollectionExtensionsGenerator : IIncrementalGenerator
    {
        private static readonly string[] s_handlersDispatchers =
        [
            "global::Minerals.AutoCQRS.ICommandDispatcher, global::Minerals.AutoCQRS.CommandDispatcher",
            "global::Minerals.AutoCQRS.IQueryDispatcher, global::Minerals.AutoCQRS.QueryDispatcher"
        ];

        private static readonly string[] s_pipelinesDispatchers =
        [
            "global::Minerals.AutoCQRS.ICommandPipelineDispatcher, global::Minerals.AutoCQRS.CommandPipelineDispatcher",
            // "global::Minerals.AutoCQRS.IQueryPipelineDispatcher, global::Minerals.AutoCQRS.QueryPipelineDispatcher"
        ];

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var handlers = context.SyntaxProvider.CreateSyntaxProvider
            (
                static (x, _) => CheckForInterfaces(x),
                static (x, _) => GetValidOrNullHandlerNameObject(x)
            ).Where(x => x is not null);

            var pipelines = context.SyntaxProvider.CreateSyntaxProvider
            (
                static (x, _) => CheckForInterfaces(x),
                static (x, _) => GetValidOrNullPipelineNameObject(x)
            ).Where(x => x is not null);

            var notNullPipelines = pipelines.Select((x, _) => (PipelineNameObject)x!);
            var notNullHandlers = handlers.Select((x, _) => (HandlerNameObject)x!);

            var collectedPipelines = notNullPipelines.Collect();

            var handlersToCheck = notNullHandlers.Combine(collectedPipelines);
            var checkedHandlers = handlersToCheck.Where(IsNotPipelineHandler);
            var collectedCheckedHandlers = checkedHandlers.Select((x, _) => x.Left).Collect();

            var combinedAll = collectedCheckedHandlers.Combine(collectedPipelines);

            context.RegisterSourceOutput(combinedAll, static (ctx, collected) =>
            {
                ctx.AddSource
                (
                    "IServiceCollectionExtensions.g.cs",
                    GenerateStaticClass(collected.Left, collected.Right)
                );
            });
        }

        private static bool CheckForInterfaces(SyntaxNode node)
        {
            return node is (not InterfaceDeclarationSyntax) and TypeDeclarationSyntax typeSyntax
                && typeSyntax.BaseList is not null
                && typeSyntax.BaseList.Types.Count > 0;
        }

        private static PipelineNameObject? GetValidOrNullPipelineNameObject(GeneratorSyntaxContext context)
        {
            var symbol = (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node)!;
            return HasValidInterfaceForPipeline(symbol) ? new PipelineNameObject(symbol) : null;
        }

        private static HandlerNameObject? GetValidOrNullHandlerNameObject(GeneratorSyntaxContext context)
        {
            var symbol = (ITypeSymbol)context.SemanticModel.GetDeclaredSymbol(context.Node)!;
            return HasValidInterfaceForHandler(symbol) ? new HandlerNameObject(symbol) : null;
        }

        private static bool HasValidInterfaceForPipeline(ITypeSymbol symbol)
        {
            return symbol.Interfaces.Any(x =>
            {
                return x.Name.Equals("ICommandPipeline")
                    && x.ContainingNamespace.Name.Equals(nameof(AutoCQRS))
                    && x.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(Minerals));
            });
        }

        private static bool HasValidInterfaceForHandler(ITypeSymbol symbol)
        {
            return symbol.Interfaces.Any(x =>
            {
                return (x.Name.Equals("ICommandHandler") || x.Name.Equals("IQueryHandler"))
                    && x.ContainingNamespace.Name.Equals(nameof(AutoCQRS))
                    && x.ContainingNamespace.ContainingNamespace.Name.Equals(nameof(Minerals));
            });
        }

        private bool IsNotPipelineHandler((HandlerNameObject Left, ImmutableArray<PipelineNameObject> Right) item)
        {
            return !item.Right.Any(x =>
            {
                return x.TypeArguments.Any(y =>
                {
                    return y.FullTypeName.Equals(item.Left.FullTypeName);
                });
            });
        }

        private static SourceText GenerateStaticClass(ImmutableArray<HandlerNameObject> handlers, ImmutableArray<PipelineNameObject> pipelines)
        {
            var builder = new CodeBuilder();
            builder.AddAutoGeneratedHeader(Assembly.GetExecutingAssembly());
            AppendNamespace(builder);

            builder.AddAutoGeneratedAttributes(typeof(ClassDeclarationSyntax));
            AppendStaticClassHeader(builder);

            AppendExtensionMethodHeader(builder, s_handlersDispatchers, "AddCommandsAndQueries");
            AppendExtensionMethodBodyForHandlers(builder, handlers);

            AppendExtensionMethodHeader(builder, s_pipelinesDispatchers, "AddCommandsAndQueriesPipelines");
            AppendExtensionMethodBodyForPipelines(builder, pipelines);

            AppendDefaultInjectPolicyMethod(builder);

            builder.CloseAllBlocks();
            return SourceText.From(builder.ToString(), Encoding.UTF8);
        }

        private static void AppendNamespace(CodeBuilder builder)
        {
            builder.WriteLine("namespace Minerals.AutoCQRS")
                .OpenBlock()
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection.Extensions;")
                .WriteLine("using global::Microsoft.Extensions.DependencyInjection;");
        }

        private static void AppendStaticClassHeader(CodeBuilder builder)
        {
            builder.WriteLine("public static class IServiceCollectionExtensions")
                .OpenBlock();
        }

        private static void AppendExtensionMethodHeader(CodeBuilder builder, IEnumerable<string> dispatchers, string methodName)
        {
            builder.WriteLine("public static global::Microsoft.Extensions.DependencyInjection.IServiceCollection ")
                .Write(methodName)
                .Write("(this global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, ")
                .Write("global::System.Action<global::Microsoft.Extensions.DependencyInjection.IServiceCollection, global::System.Type, global::System.Type> injectPolicy = null)")
                .OpenBlock();

            builder.WriteLine("if (injectPolicy is null)")
                .OpenBlock()
                .WriteLine("injectPolicy = DefaultInjectPolicy;")
                .CloseBlock();

            foreach (var item in dispatchers)
            {
                builder.WriteLine("collection.TryAddSingleton<")
                    .Write(item)
                    .Write(">();");
            }
        }

        private static void AppendExtensionMethodBodyForHandlers(CodeBuilder builder, ImmutableArray<HandlerNameObject> handlers)
        {
            foreach (var item in handlers)
            {
                builder.WriteLine("injectPolicy.Invoke(collection, typeof(")
                    .Write(item.InterfaceFullTypeName)
                    .Write("), typeof(")
                    .Write(item.FullTypeName)
                    .Write("));");
            }
            builder.WriteLine("return collection;")
                .CloseBlock()
                .NewLine();
        }

        private static void AppendExtensionMethodBodyForPipelines(CodeBuilder builder, ImmutableArray<PipelineNameObject> pipelines)
        {
            foreach (var item in pipelines)
            {
                builder.WriteLine("injectPolicy.Invoke(collection, typeof(")
                    .Write(item.InterfaceFullTypeName)
                    .Write("), typeof(")
                    .Write(item.FullTypeName)
                    .Write("));");
            }
            builder.WriteLine("return collection;")
                .CloseBlock()
                .NewLine();
        }

        private static void AppendDefaultInjectPolicyMethod(CodeBuilder builder)
        {
            builder.WriteLine("private static void DefaultInjectPolicy(global::Microsoft.Extensions.DependencyInjection.IServiceCollection collection, global::System.Type interfaceType, global::System.Type serviceType)")
                .OpenBlock()
                .WriteLine("collection.AddSingleton(interfaceType, serviceType);")
                .CloseBlock();
        }
    }
}